# 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） 周志明 著》阅读笔记

## 第二部分 自动内存管理机制

### 运行时数据区域
1. 程序计数器   
> 线程私有，内存空间较小，当前线程执行字节码（分支、循环、跳转、异常处理、线程恢复）的行号指示器   
执行Java方法时计数器记录的时字节码指令地址，执行Native方法时计数器为Undefined   
此区域没有OutOfMamaryError异常   

2. Java虚拟机栈   
> 线程私有，生命周期与线程相同   
描述Java方法执行的内存模型：每个方法执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息  
每一个方法从调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程   
局部变量表存放编译期可知的基本数据类型、对象引用和returnAddress类型，所需内存空间在编译期完成分配，方法运行时大小不变   
此区域会产生StackOverflowError和OutOfMamaryError异常    

3. 本地方法栈   
与Java虚拟机栈相似，区别是虚拟机栈为执行Java方法服务，本地方法栈为执行Native方法服务   
虚拟机规范中堆此区域无强制规定，Sun HotSpot虚拟机将本地方法栈、虚拟机栈合二为一   

4. Java堆   
线程共享区域，内存空间最大，虚拟机启动时创建，存放对象实例   
垃圾收集器管理的主要区域，可细分为新生代、老年代，新生代可再细分为Eden、From Survive、To Survive空间   
从内存分配角度来看，可划分出多个线程私有缓冲区   
内存区域不要求物理连续，要求逻辑上是连续的，可选择固定大小或扩展(通过-Xmx和-Xms控制)   
此区域
