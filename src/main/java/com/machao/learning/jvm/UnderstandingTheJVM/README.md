# 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） 周志明 著》阅读笔记

## 第二部分 自动内存管理机制

### 运行时数据区域
1. 程序计数器   
> 线程私有，内存空间较小，当前线程执行字节码（分支、循环、跳转、异常处理、线程恢复）的行号指示器   
执行Java方法时计数器记录的时字节码指令地址，执行Native方法时计数器为Undefined   
此区域没有OutOfMamaryError异常   

2. Java虚拟机栈   
> 线程私有，生命周期与线程相同   
描述Java方法执行的内存模型：每个方法执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息  
每一个方法从调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程   
局部变量表存放编译期可知的基本数据类型、对象引用和returnAddress类型，所需内存空间在编译期完成分配，方法运行时大小不变   
此区域会产生StackOverflowError和OutOfMamaryError异常    

3. 本地方法栈   
> 与Java虚拟机栈相似，区别是虚拟机栈为执行Java方法服务，本地方法栈为执行Native方法服务   
虚拟机规范中堆此区域无强制规定，Sun HotSpot虚拟机将本地方法栈、虚拟机栈合二为一   

4. Java堆   
> 线程共享区域，内存空间最大，虚拟机启动时创建，存放对象实例   
垃圾收集器管理的主要区域，可细分为新生代、老年代，新生代可再细分为Eden、From Survive、To Survive空间   
从内存分配角度来看，可划分出多个线程私有缓冲区   
内存区域不要求物理连续，要求逻辑上是连续的，可选择固定大小或扩展(通过-Xmx和-Xms控制)   
此区域有OutOfMamaryError异常   

5. 方法区   
> 线程共享，储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据   
对于HotSpot虚拟机可称为永久代，其它虚拟机无此说法，JDK1.7HotSpot已把存放于永久代的字符串常量池移出   
内存不要求物理连续，要求逻辑上连续，可选择固定大小或可扩展   
有OutOfMamaryError异常    

5.1 运行时常量池   
> 方法区的一部分，存放已加载Class文件中的常量池(符号引用、直接引用)   
具备动态性，运行期间可存入新常量，如String的intern()方法   

6. 直接内存   
> 非虚拟机运行时数据区，Java虚拟机规范中未定义   
有OutOfMamaryError异常  
使用Native函数库分配的堆外内存，可避免在Java堆和Native堆直接来回复制数据   


### HotSpot虚拟机内存中对象的布局   


### 确定对象已死的2种算法   

1. 引用计数法   
	算法思路：给对象添加引用计数器，有引用时+1，引用失效时-1，计数器为0时对象不可用    
	实现简单，判定效率高，但此算法很难解决对象之间的相互循环引用问题，因此主流Java虚拟机没有选用此算法    
2. 可达性分析法   
	基本思路：将“GC Roots”对象作为起始点，从起始点开始向下搜索，搜索经过的路径称为引用链(ReferenceChain)，当一个对象到GC Roots没有任何引用链相连时，则此对象不可用      
	在Java语言中可作为“GC Roots”的对象有：    
		虚拟机栈（栈帧中的本地变量表）中引用的对象   
		方法区中类静态属性引用的对象   
		方法区中常量引用的对象    
		本地方法栈JNI（即一般说的Native方法）引用的对象   


### Java的4种引用   
1. 强引用（StrongReference）  
	程序代码中普遍存在，类似“Object obj = new Object()”的引用   
	只要强引用还存在，垃圾收集器永远不会回收被引用的对象内存    
2. 软引用（SoftReference）   
	还有用但并非必须的对象引用   
	系统发生内存溢出异常之前，会把软引用对象列进回收范围进行第二次回收，如果回收后还没有足够内存，才会抛出内存溢出异常    
	在JDK1.2之后，提供SoftReference类实现软引用    
3. 弱引用（WeakReference）    
	也用来描述非必须引用对象，但强度比软引用更若一些   
	弱引用关联对象只能生存到下一次垃圾收集发生之前，垃圾收集器工作时，无论当前内存是否足够，都会回收掉只有弱引用关联的对象内存    
	在JDK1.2之后，提供WeakReference类实现弱引用    
4. 虚引用（PhantomReference）   
	也称之为幽灵引用、幻影引用，最弱的一种引用关系    
	对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用取得对象实例   
	为对象设置虚引用关联的唯一目的是能在这个对象被收集器回收时收到一个系统通知    
	在JDK1.2之后，提供PhantomReference类实现虚引用   
	

### 垃圾回收算法    
1. “标记-清除”（Mark-Sweep）算法   
	最基础的收集算法，后续收集算法基于此算法的思路对其不足进行改进实现    
	分为“标记”、“清除”两个阶段：   
		首先标记出所有需要回收的对象（根据“引用计数法”和“可达性分析法”）   
		标记完成后统一回收被标记的对象   
	两个不足：   
		效率问题，标记和清理两个过程的效率都不高   
		空间问题，标记清理后会产生大量不连续的内存碎片，可能会导致以后需要分配较大对象时无法找到足够的连续内存，而不得不提前触发另一次垃圾回收动作    

2. “复制”（Copying）算法   
	为了解决效率问题提出的算法    
	将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当这块内存用完就将还活着的对象复制到另一块内存中，然后把已使用的内存空间一次性清理掉   
	优点：    
		内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针分配内存即可，实现简单，运行高效    
	缺点：    
		将可用内存缩小为原来一半，代价太高    
		对象存活率较高时要进行较多复制操作，效率会变低   
	新生代中98%对象都是”朝生夕死“，因此实际上内存并非分为容量相等的2块，而是分为1个Eden和2个Survivor，每次可用内存为1个Eden和1个Survivor，复制存活对象时将这两个区域存活的对象复制到另外一个Survivor中。
	HotSpot虚拟机默认Eden:Survivor=8:1        
	分配担保：若另外1个Survivor无足够空间存放存活对象，则将对象放入老年代    
		
3. ”标记-整理“（Mark-Compact）算法    
	根据老年代特点（对象存活率较高）提出    
	标记过程与”标记-清除“算法相同，后续步骤是让存活对象向一端移动，然后直接清理掉端边界以外的内存    

4. ”分代收集“（Generational Collection）算法    
	当前商业虚拟机都采用”分代收集“算法    
	根据对象存活周期的不同将内存划分为几块（比如新生代和老年代），不同的内存区域采用不同的垃圾收集算法(”标记-清理“、”复制“和”标记-整理“这三种算法之一)    
	
	
	
### 垃圾收集器    

1. Serial收集器（串行收集器）   
	新生代收集器，采用复制算法   
	单线程执行,进行垃圾回收时必须暂停掉所有工作线程      
	垃圾收集时会产生停顿（Stop The World），随着HotSpot优化STW时间在缩短但不会消失    
	简单高效，对单核CPU环境无线程交互开销，可获得最高单线程收集效率，对Client模式虚拟机时很好的选择    
	
2. ParNew收集器（并行收集器）  
	新生代收集器，采用复制算法   
	多线程执行，其就是serial收集器的多线程版本   
	控制参数（如：-XXSurvivorRatio、-XXPretenureSizeThreshold、-XXHandlePromotionFailure等）、收集算法、STW、对象分配规则、回收策略等与Serial相同（两者共用很多代码）  
	Server模式虚拟机首选新生代收集器（原因之一是除了Serial收集器之外只有ParNew收集器能与CMS收集器搭配使用）    
	默认开启线程数量=CPU个数，可用-XXParallelGCThreads参数限制线程数    
	使用-XX+UseConMarkSweepGC后默认的新生代收集器，可使用-XX+UseParNewGC强制指定    
	
3. Parallel Scavenge收集器（并行收集器）   
	新生代收集器，采用复制算法    
	多线程执行   
	Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput），吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），比如虚拟机总共运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量为99%    
	短停顿时间适合与用户交互程序，高吞吐量可高效利用CPU时间，适合后台运算任务程序    
	参数： 
		-XXMaxGCPauseMillis，设置最大垃圾收集停顿时间，大于0的毫秒数，缩短停顿时间是以牺牲吞吐量和新生代空间实现的     
		-XXGCTimeRatio，设置吞吐量大小，大于0小于100的整数        
		-XX+UseAdaptiveSizePolicy，打开GC自适应调节策略，打开后，不需指定新生代大小（-Xmn）、Eden与Survivor比例（-XXSurvivorRatio）、晋升老年代对象年龄（-XXPretenureSizeThreshold）等细节参数     


4. Serial Old收集器（串行收集器）    
	老年代收集器，采用“标记-整理”算法    
	单线程执行    
	主要适合Client模式虚拟机使用    
	Server模式下2大用途：    
		1). 在JDK1.5及之前版本中与Parallel Scavenge收集器搭配使用    
		2). 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用    


5. Parallel Old收集器（并行收集器）    
	老年代收集器，采用“标记-整理”算法   
	多线程执行   
	JDK1.6开始提供，在此之前若新生代选择Parallel Scavenge收集器老年代只有Serial Old可选    
	Serial Old在服务端性能较差（单线程无法充分利用多CPU处理能力），与Parallel Scaveng搭配整体上不能获得最大化吞吐量，在老年代很大且硬件较高级环境，以上组合吞吐量可能不如ParNew+CMS组合 
	在注重吞吐量、CPU资源敏感场合，可优先考虑Parallel Scavenge+Parallel Old组合    
	
6. CMS（Concurrent Mark Sweep）收集器（并行收集器）    
	老年代收集器，采用“标记-清除”算法   
	多线程执行    
	CMS收集器目标：获取最短回收停顿时间 
	运行的4个步骤：    
		1). 初始标记（CMS initial mark），只标记GC Roots能直接关联到的对象，需要“Stop The World”，但时间很短    
		2). 并发标记（CMS concurrent mark），进行GC Roots Tracing的过程，不需要STW    
		3). 重新标记（CMS remark），修正并发标记期间因用户程序继续运作而导致标记产生的那一部分对象的标记记录，需要“Stop The World”，时间比初始标记阶段稍长，但比并发标记时间短很多     
		4). 并发清除（CMS concurrent sweep）
	   
	
	

